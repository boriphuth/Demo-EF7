<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EntityFramework.Commands</name>
    </assembly>
    <members>
        <member name="P:Microsoft.Data.Entity.Commands.Strings.ArgumentIsEmpty">
            <summary>
            The string argument '{argumentName}' cannot be empty.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Strings.FormatArgumentIsEmpty(System.Object)">
            <summary>
            The string argument '{argumentName}' cannot be empty.
            </summary>
        </member>
        <member name="P:Microsoft.Data.Entity.Commands.Strings.CollectionArgumentIsEmpty">
            <summary>
            The collection argument '{argumentName}' must contain at least one element.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Strings.FormatCollectionArgumentIsEmpty(System.Object)">
            <summary>
            The collection argument '{argumentName}' must contain at least one element.
            </summary>
        </member>
        <member name="P:Microsoft.Data.Entity.Commands.Strings.InvalidEnumValue">
            <summary>
            The value provided for argument '{argumentName}' must be a valid value of enum type '{enumType}'.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Strings.FormatInvalidEnumValue(System.Object,System.Object)">
            <summary>
            The value provided for argument '{argumentName}' must be a valid value of enum type '{enumType}'.
            </summary>
        </member>
        <member name="P:Microsoft.Data.Entity.Commands.Strings.DuplicateMigrationName">
            <summary>
            The name '{migrationName}' is used by an existing migration.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Strings.FormatDuplicateMigrationName(System.Object)">
            <summary>
            The name '{migrationName}' is used by an existing migration.
            </summary>
        </member>
        <member name="P:Microsoft.Data.Entity.Commands.Strings.MultipleContexts">
            <summary>
            More than one DbContext was found. Specify which one to use.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Strings.FormatMultipleContexts">
            <summary>
            More than one DbContext was found. Specify which one to use.
            </summary>
        </member>
        <member name="P:Microsoft.Data.Entity.Commands.Strings.MultipleContextsWithName">
            <summary>
            More than one DbContext named '{name}' was found. Specify which one to use by providing its fully qualified name.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Strings.FormatMultipleContextsWithName(System.Object)">
            <summary>
            More than one DbContext named '{name}' was found. Specify which one to use by providing its fully qualified name.
            </summary>
        </member>
        <member name="P:Microsoft.Data.Entity.Commands.Strings.MultipleContextsWithQualifiedName">
            <summary>
            More than one DbContext named '{name}' was found. Specify which one to use by providing its fully qualified name using its exact case.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Strings.FormatMultipleContextsWithQualifiedName(System.Object)">
            <summary>
            More than one DbContext named '{name}' was found. Specify which one to use by providing its fully qualified name using its exact case.
            </summary>
        </member>
        <member name="P:Microsoft.Data.Entity.Commands.Strings.NoContext">
            <summary>
            No DbContext was found. Ensure that you're using the correct assembly and that the type is neither abstract nor generic.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Strings.FormatNoContext">
            <summary>
            No DbContext was found. Ensure that you're using the correct assembly and that the type is neither abstract nor generic.
            </summary>
        </member>
        <member name="P:Microsoft.Data.Entity.Commands.Strings.NoContextWithName">
            <summary>
            No DbContext named '{name}' was found.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Strings.FormatNoContextWithName(System.Object)">
            <summary>
            No DbContext named '{name}' was found.
            </summary>
        </member>
        <member name="P:Microsoft.Data.Entity.Commands.Strings.LogUseContext">
            <summary>
            Using context '{name}'.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Strings.FormatLogUseContext(System.Object)">
            <summary>
            Using context '{name}'.
            </summary>
        </member>
        <member name="T:Microsoft.Data.Entity.Commands.Utilities.ForwardingProxy`1">
            <summary>
                This is a small piece of Remoting magic. It enables us to invoke methods on a
                remote object without knowing its actual type. The only restriction is that the
                names and shapes of the types and their members must be the same on each side of
                the boundary.
            </summary>
        </member>
        <member name="M:Microsoft.Data.Entity.Commands.Utilities.ForwardingProxy`1.Invoke(System.Runtime.Remoting.Messaging.IMessage)">
            <summary>
                Intercepts method invocations on the object represented by the current instance
                and forwards them to the target to finish processing.
            </summary>
        </member>
    </members>
</doc>
